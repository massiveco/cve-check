package inventory

import (
	"errors"
	"regexp"
	"strconv"
)

var pkgNameParser = regexp.MustCompile(`(?P<pkgname>\S*)-(?P<major>\d+).(?P<minor>\d+).(?P<patch>\d+)-(?P<pkgrel>r\d+)$`)

// Inventory of items on a system
type Inventory struct {
	Items []Item
}

// Item defines a single package installed on a system
type Item struct {
	Name    string
	Version Version
	Source  string
}

// Version semver decomposition
type Version struct {
	Major int
	Minor int
	Patch int
}

// NewItem parse a package name into a Item
func NewItem(pkgName string, source string) (*Item, error) {
	matches := pkgNameParser.FindStringSubmatch(pkgName)

	if len(matches) == 0 {
		return nil, errors.New("No package found")
	}
	major, err := strconv.Atoi(matches[2])
	if err != nil {
		return nil, err
	}

	minor, err := strconv.Atoi(matches[3])
	if err != nil {
		return nil, err
	}

	patch, err := strconv.Atoi(matches[4])
	if err != nil {
		return nil, err
	}

	return &Item{
		Name: matches[1],
		Version: Version{
			Major: major,
			Minor: minor,
			Patch: patch,
		},
		Source: source,
	}, nil
}
